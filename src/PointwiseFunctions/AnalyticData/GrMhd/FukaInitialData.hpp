// Distributed under the MIT License.
// See LICENSE.txt for details.

#pragma once

#include <cstddef>
#include <memory>
#include <mutex>

#include "DataStructures/Tensor/EagerMath/DotProduct.hpp"
#include "DataStructures/Tensor/Tensor.hpp"
#include "Evolution/NumericInitialData.hpp"
#include "IO/External/InterpolateFromFuka.hpp"
#include "Options/String.hpp"
#include "PointwiseFunctions/AnalyticData/GrMhd/AnalyticData.hpp"
#include "PointwiseFunctions/GeneralRelativity/Tags.hpp"
#include "PointwiseFunctions/Hydro/SpecificEnthalpy.hpp"
#include "PointwiseFunctions/Hydro/Tags.hpp"
#include "PointwiseFunctions/InitialDataUtilities/InitialData.hpp"
#include "Utilities/Serialization/CharmPupable.hpp"
#include "Utilities/TMPL.hpp"
#include "Utilities/TaggedTuple.hpp"

/// \cond
namespace PUP {
class er;
}  // namespace PUP
/// \endcond

namespace grmhd::AnalyticData {

/*!
 * \brief Hydro initial data generated by FUKA.
 *
 * This class loads numerical data written out by the FUKA initial data solver.
 *
 * We choose a constant electron fraction and zero temperature for now because
 * FUKA doesn't export these quantities. We'll have to improve this later, e.g.
 * by constructing an EOS consistent with the FUKA data.
 */
class FukaInitialData : public evolution::initial_data::InitialData,
                        public evolution::NumericInitialData,
                        public AnalyticDataBase {
 public:
  struct InfoFilename {
    using type = std::string;
    static constexpr Options::String help = {
        "Path to the '.info' file of data produced by FUKA."};
  };

  struct ElectronFraction {
    using type = double;
    static constexpr Options::String help = {"Constant electron fraction"};
  };

  using options = tmpl::list<InfoFilename, ElectronFraction>;

  static constexpr Options::String help = {"Initial data generated by FUKA"};

  FukaInitialData() = default;
  FukaInitialData(const FukaInitialData& rhs);
  FukaInitialData& operator=(const FukaInitialData& rhs);
  FukaInitialData(FukaInitialData&& rhs);
  FukaInitialData& operator=(FukaInitialData&& rhs);
  ~FukaInitialData() override = default;

  FukaInitialData(std::string info_filename, double electron_fraction);

  auto get_clone() const
      -> std::unique_ptr<evolution::initial_data::InitialData> override;

  /// \cond
  explicit FukaInitialData(CkMigrateMessage* msg);
  using PUP::able::register_constructor;
  WRAPPED_PUPable_decl_template(FukaInitialData);
  /// \endcond

  template <typename DataType>
  using tags = tmpl::append<
      tmpl::list<gr::Tags::SpatialMetric<DataType, 3>,
                 gr::Tags::ExtrinsicCurvature<DataType, 3>,
                 gr::Tags::Lapse<DataType>, gr::Tags::Shift<DataType, 3>>,
      hydro::grmhd_tags<DataType>>;

  template <typename... RequestedTags>
  tuples::TaggedTuple<RequestedTags...> variables(
      const tnsr::I<DataVector, 3>& x,
      tmpl::list<RequestedTags...> /*meta*/) const {
    auto interpolated_vars = io::interpolate_from_fuka<io::FukaIdType::Bns>(
        make_not_null(&fuka_lock_), info_filename_, x);
    tuples::TaggedTuple<RequestedTags...> result{};
    // Move interpolated data into result buffer
    tmpl::for_each<
        tmpl::list<gr::Tags::Lapse<DataVector>, gr::Tags::Shift<DataVector, 3>,
                   gr::Tags::SpatialMetric<DataVector, 3>,
                   gr::Tags::ExtrinsicCurvature<DataVector, 3>,
                   hydro::Tags::RestMassDensity<DataVector>,
                   hydro::Tags::SpecificInternalEnergy<DataVector>,
                   hydro::Tags::Pressure<DataVector>,
                   hydro::Tags::SpatialVelocity<DataVector, 3>>>(
        [&result, &interpolated_vars](const auto tag_v) {
          using tag = tmpl::type_from<std::decay_t<decltype(tag_v)>>;
          get<tag>(result) = std::move(get<tag>(interpolated_vars));
        });
    // Compute derived quantities from interpolated data
    const size_t num_points = x.begin()->size();
    const auto& rest_mass_density =
        get<hydro::Tags::RestMassDensity<DataVector>>(result);
    const auto& specific_internal_energy =
        get<hydro::Tags::SpecificInternalEnergy<DataVector>>(result);
    const auto& pressure = get<hydro::Tags::Pressure<DataVector>>(result);
    const auto& spatial_velocity =
        get<hydro::Tags::SpatialVelocity<DataVector, 3>>(result);
    const auto& spatial_metric =
        get<gr::Tags::SpatialMetric<DataVector, 3>>(result);
    // Compute enthalpy from internal energy and pressure
    auto& specific_enthalpy =
        get<hydro::Tags::SpecificEnthalpy<DataVector>>(result);
    get(specific_enthalpy) = DataVector(num_points);
    for (size_t i = 0; i < num_points; ++i) {
      const double local_rest_mass_density = get(rest_mass_density)[i];
      if (equal_within_roundoff(local_rest_mass_density, 0.)) {
        get(specific_enthalpy)[i] = 1.;
      } else {
        get(specific_enthalpy)[i] = get(hydro::relativistic_specific_enthalpy(
            Scalar<double>(local_rest_mass_density),
            Scalar<double>(get(specific_internal_energy)[i]),
            Scalar<double>(get(pressure)[i])));
      }
    }
    // Constant electron fraction specified by input file
    auto& electron_fraction =
        get<hydro::Tags::ElectronFraction<DataVector>>(result);
    get(electron_fraction) = DataVector(num_points, electron_fraction_);
    // Zero magnetic field and divergence cleaning field
    auto& magnetic_field =
        get<hydro::Tags::MagneticField<DataVector, 3>>(result);
    get<0>(magnetic_field) = DataVector(num_points, 0.);
    get<1>(magnetic_field) = DataVector(num_points, 0.);
    get<2>(magnetic_field) = DataVector(num_points, 0.);
    auto& div_cleaning_field =
        get<hydro::Tags::DivergenceCleaningField<DataVector>>(result);
    get(div_cleaning_field) = DataVector(num_points, 0.);
    // Compute Lorentz factor from spatial velocity
    auto& lorentz_factor = get<hydro::Tags::LorentzFactor<DataVector>>(result);
    get(lorentz_factor) =
        1. / sqrt(1. - get(dot_product(spatial_velocity, spatial_velocity,
                                       spatial_metric)));
    // Set temperature to zero for now
    auto& temperature = get<hydro::Tags::Temperature<DataVector>>(result);
    get(temperature) = DataVector(num_points, 0.);
    return result;
  }

  // NOLINTNEXTLINE(google-runtime-references)
  void pup(PUP::er& /*p*/) override;

 private:
  std::string info_filename_{};
  double electron_fraction_ = std::numeric_limits<double>::signaling_NaN();

  // This lock is used to ensure that only one thread at a time is calling the
  // FUKA interpolation routines. We make some assumptions here to guarantee
  // thread-safety:
  // - This analytic data class exists only once per node (in the global cache).
  //   This means we don't have to copy or PUP the lock or pass it around
  //   instances.
  // - This also allows the lock to be mutable, which is necessary for the
  //   const-ness of the `variables` function.
  mutable std::mutex fuka_lock_{};  // NOLINT(spectre-mutable)
};

}  // namespace grmhd::AnalyticData
