// Distributed under the MIT License.
// See LICENSE.txt for details.

#pragma once

#include <Exporter.hpp>  // The SpEC Exporter
#include <limits>
#include <memory>

#include "DataStructures/CachedTempBuffer.hpp"
#include "DataStructures/Tensor/EagerMath/DeterminantAndInverse.hpp"
#include "Elliptic/Systems/IrrotationalBns/FirstOrderSystem.hpp"
#include "Elliptic/Systems/IrrotationalBns/Tags.hpp"
#include "Evolution/NumericInitialData.hpp"
#include "NumericalAlgorithms/LinearOperators/PartialDerivatives.hpp"
#include "Options/String.hpp"
#include "PointwiseFunctions/AnalyticData/IrrotationalBns/TovStar.hpp"
#include "PointwiseFunctions/GeneralRelativity/Tags.hpp"
#include "PointwiseFunctions/Hydro/EquationsOfState/EquationOfState.hpp"
#include "PointwiseFunctions/Hydro/InitialData/IrrotationalBns.hpp"
#include "PointwiseFunctions/Hydro/Tags.hpp"
#include "PointwiseFunctions/InitialDataUtilities/InitialData.hpp"
#include "Utilities/Serialization/CharmPupable.hpp"
#include "Utilities/TMPL.hpp"
#include "Utilities/TaggedTuple.hpp"

/// \cond
namespace PUP {
class er;
}  // namespace PUP
/// \endcond

namespace IrrotationalBns::InitialData {

/*!
 * \brief Hydro initial data generated by SpEC.
 *
 * This class loads numerical data written out by the SpEC initial data solver.
 * It uses the `spec::Exporter` linked in from SpEC to interpolate to arbitrary
 * grid points. The coordinates are assumed to be in SpEC's "grid" frame.
 * We interpolate the following quantities:
 *
 * - "g": spatial metric
 * - "K": (lower) extrinsic curvature
 * - "Lapse": lapse
 * - "Shift": (upper) shift
 * - "BaryonDensity": rest mass density
 * - "u_i": lower spatial four-velocity
 *
 * The remaining hydro quantities are computed from the interpolated data and
 * the equation of state.
 * The magnetic field is set to zero and the electron fraction is set to a
 * constant read from the input file.
 */
template <size_t ThermodynamicDim>
class SpecInitialData : public evolution::initial_data::InitialData,
                        public evolution::NumericInitialData {
 public:
  using equation_of_state_type =
      EquationsOfState::EquationOfState<true, ThermodynamicDim>;

  template <typename DataType>
  using variable_tags =
      tmpl::list<IrrotationalBns::Tags::VelocityPotential<DataType>>;
  template <typename DataType>
  using background_tags = tmpl::list<
      gr::Tags::SpatialMetric<DataType, 3>,
      gr::Tags::InverseSpatialMetric<DataType, 3>,
      gr::Tags::ExtrinsicCurvature<DataType, 3>, gr::Tags::Lapse<DataType>,
      gr::Tags::Shift<DataType, 3>,
      IrrotationalBns::Tags::RotationalShift<DataType>,
      IrrotationalBns::Tags::DerivLogLapseOverSpecificEnthalpy<DataType>,
      IrrotationalBns::Tags::RotationalShiftStress<DataType>,
      ::Tags::deriv<gr::Tags::Shift<DataType, 3>,
                    tmpl::integral_constant<size_t, 3>, Frame::Inertial>,
      ::Tags::deriv<gr::Tags::Lapse<DataType>,
                    tmpl::integral_constant<size_t, 3>, Frame::Inertial>,
      Tags::FixedSources<Tags::VelocityPotential<DataType>>>;
  template <typename DataType>
  using tags = tmpl::append<background_tags<DataType>, variable_tags<DataType>>;

  struct DataDirectory {
    using type = std::string;
    static constexpr Options::String help = {
        "Path to a directory of data produced by SpEC. The directory is "
        "expected to contain 'GrDomain.input' and 'Vars*.h5' files for all the "
        "subdomains in GrDomain.input."};
  };

  struct DensityCutoff {
    using type = double;
    static constexpr Options::String help =
        "Where the density is below this cutoff the fluid variables are set to "
        "vacuum (zero density, pressure, energy and velocity, unit Lorentz "
        "factor and enthalpy). "
        "During the evolution, atmosphere treatment will typically kick in and "
        "fix the value of the fluid variables in these regions. Therefore, "
        "it makes sense to set this density cutoff to the same value as the "
        "atmosphere density cutoff.";
  };

  using options =
      tmpl::list<DataDirectory,
                 hydro::OptionTags::EquationOfState<true, ThermodynamicDim>,
                 DensityCutoff,
                 IrrotationalBns::InitialData::TovStar::OrbitalAngularVelocity,
                 IrrotationalBns::InitialData::TovStar::EulerEnthalpyConstant,
                 IrrotationalBns::InitialData::TovStar::StarCenter>;

  static constexpr Options::String help = {"Initial data generated by SpEC"};

  SpecInitialData() = default;
  SpecInitialData(const SpecInitialData& rhs);
  SpecInitialData& operator=(const SpecInitialData& rhs);
  SpecInitialData(SpecInitialData&& /*rhs*/) = default;
  SpecInitialData& operator=(SpecInitialData&& /*rhs*/) = default;
  ~SpecInitialData() override = default;

  SpecInitialData(std::string data_directory,
                  std::unique_ptr<equation_of_state_type> equation_of_state,
                  double density_cutoff, double orbital_angular_velocity,
                  double euler_enthalpy_constant);

  auto get_clone() const
      -> std::unique_ptr<evolution::initial_data::InitialData> override;

  /// \cond
  explicit SpecInitialData(CkMigrateMessage* msg);
  using PUP::able::register_constructor;
  WRAPPED_PUPable_decl_template(SpecInitialData);
  /// \endcond
  const equation_of_state_type& equation_of_state() const {
    return *equation_of_state_;
  }
  // The velocity potential is used in the initial guess
  tuples::TaggedTuple<Tags::VelocityPotential<DataVector>> variables(
      const tnsr::I<DataVector, 3, Frame::Inertial>& x,
      tmpl::list<Tags::VelocityPotential<DataVector>> /*meta*/) const {
    // return velocity potential (only a guess)
    auto velocity_potential = make_with_value<Scalar<DataVector>>(x, 0.0);
    get(velocity_potential) =
        star_center_[1] * x.get(0) * orbital_angular_velocity +
        star_center_[0] * x.get(1) * orbital_angular_velocity;
    tuples::TaggedTuple<Tags::VelocityPotential<DataVector>> result{};
    get<Tags::VelocityPotential<DataVector>>(result) = velocity_potential;
    return result;
  }
  // The fixed sources are used in  initialization
  tuples::TaggedTuple<Tags::FixedSources<Tags::VelocityPotential<DataVector>>>
  variables(const tnsr::I<DataVector, 3, Frame::Inertial>& x,
            const Mesh<3>& mesh,
            const InverseJacobian<DataVector, 3, Frame::ElementLogical,
                                  Frame::Inertial>& inv_jacobian,
            tmpl::list<Tags::FixedSources<
                Tags::VelocityPotential<DataVector>>> /*meta*/) const {
    auto background_values =
        variables(x, mesh, inv_jacobian, background_tags<DataVector>{});
    tuples::TaggedTuple<Tags::FixedSources<Tags::VelocityPotential<DataVector>>>
        result{};
    get<Tags::FixedSources<Tags::VelocityPotential<DataVector>>>(result) =
        get<Tags::FixedSources<Tags::VelocityPotential<DataVector>>>(
            background_values);
    return result;
  }

  tuples::TaggedTuple<gr::Tags::InverseSpatialMetric<DataVector, 3>> variables(
      const tnsr::I<DataVector, 3, Frame::Inertial>& x,
      tmpl::list<gr::Tags::InverseSpatialMetric<DataVector, 3>> /*meta*/)
      const {
    // interpolate from spec, then set gamma
    auto interpolated_vars = interpolate_from_spec(x);
    auto spatial_metric =
        get<gr::Tags::SpatialMetric<DataVector, 3>>(interpolated_vars);
    tuples::TaggedTuple<gr::Tags::InverseSpatialMetric<DataVector, 3>> result{};
    get<gr::Tags::InverseSpatialMetric<DataVector, 3>>(result) =
        determinant_and_inverse(spatial_metric).second
  }

  tuples::TaggedTuple<background_tags<DataVector>> variables(
      const tnsr::I<DataVector, 3, Frame::Inertial>& x, const Mesh<3>& mesh,
      const InverseJacobian<DataVector, 3, Frame::ElementLogical,
                            Frame::Inertial>& inv_jacobian,
      background_tags<DataVector> /*meta*/) const {
    // interpolate from spec, take num derivatives, return
    // Shift, lapse spatial metric imported
    auto result = tuples::TaggedTuple<background_tags<DataVector>>{};
    auto interpolated_vars = interpolate_from_spec(x);
    auto spatial_metric =
        get<gr::Tags::SpatialMetric<DataVector, 3>>(interpolated_vars);
    auto spatial_metric_determinant_and_inverse =
        determinant_and_inverse(spatial_metric);
    auto inv_spatial_metric = spatial_metric_determinant_and_inverse.second;
    get<gr::Tags::InverseSpatialMetric<DataVector, 3>>(result) =
        inv_spatial_metric;
    auto sqrt_det_spatial_metric = Scalar<DataVector>{
        sqrt(get(spatial_metric_determinant_and_inverse.first))};
    // Get the one contracted Christoffel needed for fluxes (is there a more
    // uniform way to do this?)
    const auto spatial_christoffel_second_kind_contracted =
        tenex::evaluate<ti::j>(
            0.5 *
            partial_derivative(
                get<gr::Tags::SpatialMetric<DataVector, 3>>(interpolated_vars),
                mesh, inv_jacobian)(ti::i, ti::j, ti::k) *
            inv_spatial_metric(ti::J, ti::K));
    get<gr::Tags::SpatialChristoffelSecondKindContracted<DataVector, 3>>(
        result) = spatial_christoffel_second_kind_contracted;
    get<gr::Tags::Lapse<DataVector>>(result) =
        get<gr::Tags::Lapse<DataVector>>(interpolated_vars);

    // Get Lapse and shift derivatives
    get<::Tags::deriv<gr::Tags::Lapse<DataVector>,
                      tmpl::integral_constant<size_t, 3>, Frame::Inertial>>(
        result) =
        partial_derivative(get<gr::Tags::Lapse<DataVector>>(interpolated_vars),
                           mesh, inv_jacobian);
    get<gr::Tags::Shift<DataVector, 3>> =
        get<gr::Tags::Shift<DataVector, 3>>(interpolated_vars);
    get<::Tags::deriv<gr::Tags::Shift<DataVector, 3>,
                      tmpl::integral_constant<size_t, 3>, Frame::Inertial>>(
        result) =
        partial_derivative(
            get<gr::Tags::Shift<DataVector, 3>>(interpolated_vars), mesh,
            inv_jacobian);
    // Get the rotational shift + deriv of log lapse over enthalpy + stress
    const auto spatial_rotational_killing_vector = hydro::initial_data::
        irrotational_bns::spatial_rotational_killing_vector(
            x,
            make_with_value<Scalar<DataVector>>(sqrt_det_spatial_metric,
                                                orbital_angular_velocity),
            sqrt_det_spatial_metric);
    const auto rotational_shift =
        hydro::initial_data::irrotational_bns::rotational_shift(
            get<gr::Tags::Shift<DataVector, 3>>(interpolated_vars),
            spatial_rotational_killing_vector);
    get<Tags::RotationalShift<DataVector>>(result) = rotational_shift;
    const auto rest_mass_density =
        get<hydro::Tags::RestMassDensity<DataVector>>(interpolated_vars);
    // The SpEC solution should have e.g. B&S Eq. 15.76 satisfied
    // so this is equivalent to some expression in the other  hydro variables
    const DataVector enthalpy_density =
        get(equation_of_state_.pressure_from_rest_mass_density(
            rest_mass_density)) +
        get(rest_mass_density) *
            (1.0 +
             get(equation_of_state_.internal_energy_from_rest_mass_density(
                 rest_mass_density)));
    const auto deriv_log_lapse_over_specific_enthalpy = partial_derivative(
        Scalar<DataVector>{
            get(get<gr::Tags::Lapse<DataVector>>(interpolated_vars)) *
            rest_mass_density / enthalpy_density},
        mesh, inv_jacobian);
    get<Tags::DerivLogLapseOverSpecificEnthalpy<DataVector>>(result) =
        deriv_log_lapse_over_specific_enthalpy;
    const auto rotational_shift_stress =
        hydro::initial_data::irrotational_bns::rotational_shift_stress(
            rotational_shift,
            get<gr::Tags::Lapse<DataVector>>(interpolated_vars));
    get<Tags::RotationalShiftStress<DataVector>>(result) =
        rotational_shift_stress;
    // Compute fixed sources
    return result;
  }
  template <typename DataType, typename... Tags>
  tuples::TaggedTuple<Tags...> variables(const tnsr::I<DataType, 3>& x,
                                         tmpl::list<Tags...> /*meta*/) const {
    auto interpolated_vars = interpolate_from_spec(x);
    using requested_tags = tmpl::list<Tags...>;
    using requested_derived_tags =
        tmpl::list_difference<requested_tags, interpolated_tags<DataType>>;
    using requested_interpolated_tags =
        tmpl::list_difference<requested_tags, requested_derived_tags>;
    tuples::TaggedTuple<Tags...> result{};
    // First, compute derived quantities from interpolated data
    if constexpr (tmpl::size<requested_derived_tags>::value > 0) {
      VariablesCache<DataType> cache{get_size(get<0>(x))};
      const VariablesComputer<DataType> computer{
          interpolated_vars, *equation_of_state_, density_cutoff_,
          orbital_angular_velocity_, euler_enthalpy_constant_};
      tmpl::for_each<requested_derived_tags>(
          [&result, &cache, &computer](const auto tag_v) {
            using tag = tmpl::type_from<std::decay_t<decltype(tag_v)>>;
            get<tag>(result) = cache.get_var(computer, tag{});
          });
    }
    // Then, move interpolated data into result buffer
    tmpl::for_each<requested_interpolated_tags>(
        [&result, &interpolated_vars](const auto tag_v) {
          using tag = tmpl::type_from<std::decay_t<decltype(tag_v)>>;
          get<tag>(result) = std::move(get<tag>(interpolated_vars));
        });
    return result;
  }

  // NOLINTNEXTLINE(google-runtime-references)
  void pup(PUP::er& /*p*/) override;

 private:
  /// These quantities are supported for interpolation from SpEC
  template <typename DataType>
  using interpolated_tags = tmpl::list<
      // GR quantities
      gr::Tags::SpatialMetric<DataType, 3>,
      gr::Tags::ExtrinsicCurvature<DataType, 3>, gr::Tags::Lapse<DataType>,
      gr::Tags::Shift<DataType, 3>,
      // Hydro quantities
      hydro::Tags::RestMassDensity<DataType>,
      hydro::Tags::LowerSpatialFourVelocity<DataType, 3>>;

  /// These are the names in SpEC datasets corresponding to the quantities above
  static const inline std::vector<std::string> vars_to_interpolate_{
      // GR quantities
      "g", "K", "Lapse", "Shift",
      // Hydro quantities
      "BaryonDensity", "u_i"};

  template <typename DataType>
  tuples::tagged_tuple_from_typelist<interpolated_tags<DataType>>
  interpolate_from_spec(const tnsr::I<DataType, 3>& x) const;

  /// This cache computes all derived quantities from the interpolated
  /// quantities on demand
  template <typename DataType>
  using VariablesCache = cached_temp_buffer_from_typelist<tmpl::push_back<
      tmpl::list_difference<tags<DataType>, interpolated_tags<DataType>>,
      hydro::Tags::LorentzFactorTimesSpatialVelocity<DataType, 3>,
      gr::Tags::InverseSpatialMetric<DataType, 3>>>;

  std::string data_directory_{};
  std::unique_ptr<equation_of_state_type> equation_of_state_{nullptr};
  double density_cutoff_ = std::numeric_limits<double>::signaling_NaN();
  double orbital_angular_velocity =
      std::numeric_limits<double>::signaling_NaN();
  double euler_enthalpy_constant = std::numeric_limits<double>::signaling_NaN();
  std::array<double, 3> star_center_;
  std::unique_ptr<spec::Exporter> spec_exporter_{nullptr};
};

}  // namespace IrrotationalBns::InitialData
