// Distributed under the MIT License.
// See LICENSE.txt for details.

#pragma once

#include <Exporter.hpp>  // The SpEC Exporter
#include <memory>

#include "Options/String.hpp"
#include "PointwiseFunctions/AnalyticData/AnalyticData.hpp"
#include "PointwiseFunctions/AnalyticData/GeneralRelativity/AnalyticData.hpp"
#include "PointwiseFunctions/GeneralRelativity/Tags.hpp"
#include "PointwiseFunctions/InitialDataUtilities/InitialData.hpp"
#include "Utilities/Serialization/CharmPupable.hpp"
#include "Utilities/TMPL.hpp"
#include "Utilities/TaggedTuple.hpp"

/// \cond
namespace PUP {
class er;
}  // namespace PUP
/// \endcond

namespace gr::AnalyticData {

/*!
 * \brief Vacuum initial data generated by SpEC.
 *
 * This class loads numerical data written out by the SpEC initial data solver.
 * It uses the `spec::Exporter` linked in from SpEC to interpolate to arbitrary
 * grid points. The coordinates are assumed to be in SpEC's "grid" frame.
 * We interpolate the following quantities:
 *
 * - "Nid_g": spatial metric
 * - "Nid_K": (lower) extrinsic curvature
 * - "Nid_N": lapse
 * - "Nid_Shift": (upper) shift
 */
class SpecInitialData : public evolution::initial_data::InitialData,
                        public MarkAsAnalyticData,
                        public AnalyticDataBase<3> {
 public:
  template <typename DataType>
  using tags =
      tmpl::list<gr::Tags::SpatialMetric<DataType, 3>,
                 gr::Tags::ExtrinsicCurvature<DataType, 3>,
                 gr::Tags::Lapse<DataType>,
                 gr::Tags::Shift<DataType, 3>>;

  struct DataDirectory {
    using type = std::string;
    static constexpr Options::String help = {
        "Path to a directory of data produced by SpEC. The directory is "
        "expected to contain 'GrDomain.input' and 'Vars*.h5' files for all the "
        "subdomains in GrDomain.input."};
  };

  using options = tmpl::list<DataDirectory>;

  static constexpr Options::String help = {"Initial data generated by SpEC"};

  SpecInitialData() = default;
  SpecInitialData(const SpecInitialData& rhs);
  SpecInitialData& operator=(const SpecInitialData& rhs);
  SpecInitialData(SpecInitialData&& /*rhs*/) = default;
  SpecInitialData& operator=(SpecInitialData&& /*rhs*/) = default;
  ~SpecInitialData() = default;

  SpecInitialData(std::string data_directory);

  auto get_clone() const
      -> std::unique_ptr<evolution::initial_data::InitialData> override;

  /// \cond
  explicit SpecInitialData(CkMigrateMessage* msg);
  using PUP::able::register_constructor;
  WRAPPED_PUPable_decl_template(SpecInitialData);
  /// \endcond

  template <typename DataType, typename... Tags>
  tuples::TaggedTuple<Tags...> variables(const tnsr::I<DataType, 3>& x,
                                         tmpl::list<Tags...> /*meta*/) const {
    auto interpolated_vars = interpolate_from_spec(x);
    return {std::move(get<Tags>(interpolated_vars))...};
  }

  // NOLINTNEXTLINE(google-runtime-references)
  void pup(PUP::er& /*p*/) override;

 private:
  /// These quantities are supported for interpolation from SpEC
  template <typename DataType>
  using interpolated_tags =
      tmpl::list<gr::Tags::SpatialMetric<DataType, 3>,
                 gr::Tags::ExtrinsicCurvature<DataType, 3>,
                 gr::Tags::Lapse<DataType>,
                 gr::Tags::Shift<DataType, 3>>;

  /// These are the names in SpEC datasets corresponding to the quantities above
  static const inline std::vector<std::string> vars_to_interpolate_{
      "Nid_g", "Nid_K", "Nid_N", "Nid_Shift"};

  template <typename DataType>
  tuples::tagged_tuple_from_typelist<interpolated_tags<DataType>>
  interpolate_from_spec(const tnsr::I<DataType, 3>& x) const;

  std::string data_directory_{};

  std::unique_ptr<spec::Exporter> spec_exporter_{nullptr};
};

}  // namespace gr::AnalyticData
