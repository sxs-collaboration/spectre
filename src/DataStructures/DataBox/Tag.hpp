// Distributed under the MIT License.
// See LICENSE.txt for details.

#pragma once

namespace db {
/*!
 * \ingroup DataBoxGroup
 * \brief Mark a struct as a simple tag by inheriting from this.
 *
 * \details
 * A simple tag is used to uniquely identify an item in a tagged container such
 * as a `DataBox`, `Variables`, or tuples::TaggedTuple.
 *
 * A simple tag may be the base class of a compute tag. In such a case, the
 * simple tag can be used to fetch the item corresponding to the compute tag
 * from a DataBox.
 *
 * A simple tag may be derived from a base tag.  In such a case, the base tag
 * can be used to fetch the item corresponding to the simple tag from a DataBox.
 * Also the simple tags should have a type alias `base` that is the base tag.
 *
 * \derivedrequires
 * - type alias `type` of the type of the item corresponding to the simple tag
 *
 * A simple tag may optionally specify a static `std::string name()` method to
 * override the default name produced by db::tag_name.
 *
 * \warning Do not derive a simple tag from another simple tag.
 *
 * \example
 * \snippet Test_DataBox.cpp databox_tag_example
 *
 * \see DataBoxGroup BaseTag ComputeTag PrefixTag
 */
struct SimpleTag {};

/*!
 * \ingroup DataBoxGroup
 * \brief Mark a (usually) empty struct as a base tag by inheriting from this.
 *
 * \details
 * A base tag may be the base class of a simple tag.  In such a case, the base
 * tag can be used to fetch the item corresponding to the simple tag (or a
 * compute tag derived from that simple tag) from a DataBox.
 *
 * Base tags are empty structs and therefore do not contain information about
 * the type of the object to which they refer.  Base tags are designed so that
 * retrieving items from the DataBox or setting argument tags in compute items
 * can be done without any knowledge of the type of the item.
 *
 * Base tags should be used rarely, only in cases where it is difficult to
 * propagate the type information to the call site.  Please consult a core
 * developer before introducing a new base tag.
 *
 * By convention, the name of a base tag should either be the name of the simple
 * tag that derives from it appended by `Base`.  Alternatively, if the simple
 * tag is templated with a type used to determine its `type` type alias, the
 * base tag can have the same name as the simple tag template with an empty
 * template parameter list.
 *
 * A base tag may optionally specify a static `std::string name()` method to
 * override the default name produced by db::tag_name.
 *
 * \warning Do not derive a base tag from anything besides db::BaseTag.
 *
 * \see DataBoxGroup SimpleTag
 */
struct BaseTag {};

/*!
 * \ingroup DataBoxGroup
 * \brief Mark a struct as a prefix tag by inheriting from this.
 *
 * \details
 * A prefix tag is used to create a new simple tag from another simple tag, and
 * therefore should also be marked as a simple tag by inheriting from
 * db::SimpleTag.
 *
 * The primary reason to mark a simple tag as a prefix tag is that the name
 * generated by db::tag_name will be constructed from the names of the prefix
 * tag and the wrapped simple tag.
 *
 * \derivedrequires
 * - type alias `tag` of the wrapped simple tag
 * - type alias `type` of the type of the item corresponding to the prefix tag
 *
 * A prefix tag may optionally specify a static `std::string name()` method to
 * override the default name produced by db::tag_name.
 *
 * \warning A prefix tag should only be derived from db::PrefixTag and
 * db::SimpleTag.
 *
 * \warning A prefix tag should only wrap a single tag.  This is assumed by all
 * metafunctions that make use of the `tag` type alias of a prefix tag.
 *
 * \example
 * A PrefixTag tag has the structure:
 * \snippet Test_DataBox.cpp databox_prefix_tag_example
 *
 * \see SimpleTag
 */
struct PrefixTag {};

/*!
 * \ingroup DataBoxGroup
 * \brief Mark a struct as a compute tag by inheriting from this.
 *
 * \details
 * A compute tag is used to identify an item in a DataBox that will be computed
 * on-demand from other items in the DataBox.  A compute tag must be derived
 * from a simple tag corresponding to the type of object that is computed.  This
 * simple tag can be used to fetch the item corresponding to the compute tag
 * from a DataBox.
 *
 * A compute tag contains a member named `function` that is either a static
 * constexpr function pointer, or a static function. The compute tag must also
 * have a a type alias `argument_tags` that is a typelist of the tags that will
 * be retrieved from the DataBox and whose data will be passed to the function
 * (pointer). Compute tags must also contain a type alias named `return_type`
 * that is the type the function is mutating. The type must be default
 * constructible.
 *
 * By convention, the name of a compute tag should be the name of the simple tag
 * that it derives from, appended by `Compute`.
 *
 * \derivedrequires
 * - type alias `return_type` of the type of the item computed
 * - type alias `base` that is the simple tag from which it is derived
 * - member `function`that is either a function pointer, or a static constexpr
 *   function that is used to compute the item from the `argument_tags` fetched
 *   from the DataBox
 * - type alias `argument_tags` that is a `tmpl::list` of the tags of the items
 *   that will be passed (in order) to the function specified by `function`
 *
 * A compute tag may optionally specify a static `std::string name()` method to
 * override the default name produced by db::tag_name.
 *
 * \warning A compute tag should only be derived from a simple tag and
 * db::ComputeTag.
 *
 * \example
 * Compute tags are of the form:
 * \snippet Test_DataBox.cpp databox_mutating_compute_item_tag
 * where the function is:
 * \snippet Test_DataBox.cpp databox_mutating_compute_item_function
 *
 * You can also have `function` be a function instead of a function pointer,
 * which offers a lot of simplicity for very simple compute items.
 * \snippet Test_DataBox.cpp compute_item_tag_function
 *
 * Note that the arguments can be empty:
 * \snippet Test_DataBox.cpp compute_item_tag_no_tags
 *
 * \see DataBoxGroup SimpleTag
 */
struct ComputeTag {};
}  // namespace db
